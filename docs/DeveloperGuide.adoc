= TutorHelper - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
:experimental:
endif::[]
:repoURL: https://github.com/CS2103-AY1819S1-W13-4/main/tree/master

== Value Proposition

Current: +

* `Tutors use reminder applications to keep track of lessons`
* `Tutors use physical diaries or notepads to keep track of current lesson progress`

Value:

* `Tutors have a platform where they can keep track of all their students' details, their progress and the syllabus they intend to cover.`

== User Stories

. As a busy tutor, I want to be able to manage my students' schedules individually, so that I can plan my time properly.
. As a tutor, I want to be able to find out where my students live and what time I should be there for tuition.
. As a tutor, I want to know my students' individual progress so that I know what topics I need to cover for the next tuition session.
. As a tutor, I want to keep track of my students' payments.

== Use Cases

  1. Add Student

  System: TutorHelper
  Actor: Tutor
  MSS:
    1. Tutor inputs to add a student and his/her details.
    2. System adds student details into the database.
    Use case ends.
  Extensions:
    2a. Index is out of bounds
      2a1. System displays error message.

  2. Edit Student

  System: TutorHelper
  Actor: Tutor
  MSS:
    1. Tutor inputs to edit a student's details.
    2. System edits student details into the database.
    Use case ends.
  Extensions:
    2a. Index is out of bounds
      2a1. System displays error message.

  3. Delete Student

  System: TutorHelper
  Actor: Tutor
  MSS:
    1. Tutor inputs student's index to delete.
    2. System deletes student details from the database.
    Use case ends.
  Extensions:
    2a. Index is out of bounds
      2a1. System displays error message.

  4. List Students

  System: TutorHelper
  Actor: Tutor
  MSS:
    1. Tutor requests to list students.
    2. System displays current list of students.
    Use case ends.

  5. Group Students

  System: TutorHelper
  Actor: Tutor
  Precondition: Current list of students is not empty.
  MSS:
    1. Tutor requests to group students by day or timing.
    2. System filters the current list of students based on the timing entered.
    3. System sorts the filtered list of students in order of timing.
    4. System displays filtered and sorted list to Tutor.
    Use case ends.
  Extensions:
    2a. Input is invalid
      2a1. System displays examples of valid input to Tutor.
    2b. Tutor does not input a day or timing
      2b1. System retrieves current date.
      2b2. System filters out students with tuition before current date.
      2b3. Resume from step 3.

  6. Record students' payments

    System: TutorHelper
    Actor: Tutor
    Precondition: student index entered must be valid.
    MSS:
      1. Tutor request to add in payment for a student.
      2. System searches for that student according to index entered.
      3. System adds Payment amount, month and year to student's record.
      4. System displays payment record in browser panel.
      5. System displays successful recording of payment under command box.
     Extensions:
      2a. Tutor does not enter all the required entries correctly
        2a1. System displays error message
        2a2. System gives tutor an example of a correct entry.
      2b. Tutor does not enter a valid student index
        2b1. System displays error message telling tutor that index is invalid

  7. Display tutor's earnings for that month and year

     System: TutorHelper
     Actor: Tutor
     Precondition: Tutor has recorded payment from students before.
     MSS:
        1. Tutor request for earnings for a specific month and year.
        2. System searches for all the payment records made from all the students for that particular month and year.
        3. System adds up all the payment.
        4. System displays total earnings under the command box.
     Extensions:
        2a. System does not find any payment recorded for that month and year.
            2a1. System displays $0 as result.

== Non-Functional Requirements

. The system should respond in two seconds.
. The system should be understandable to a novice in working with computers.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::group[]
=== Group Students feature
==== Current Implementation

Classes related to Group and its functionality is listed below:

* `AddressBookParser` -- Creates a GroupCommandParser object and parses the user's input.
* `GroupCommandParser` -- Analyses the input, creates a predicate based on the input and returns a GroupCommand object with the predicate as the argument.
* `GroupCommand` -- Filters the list based on the predicate and displays it to the user.

Given below is an example usage scenario and how the group mechanism behaves at each step.

Step 1. The user launches the application for the first time.

Step 2. Assuming that the application isn't empty, the user executes 'group Monday' command to group all students with a class on Monday. The group command will be called by `GroupCommandParser.parse()`, parsing the argument to check against. The application will check the list and display all students with classes on Monday, sorted based on the earliest timing.

[NOTE]
The user can execute `list` to re-display the full list of students again.
[NOTE]
The group command is CASE-SENSITIVE. E.g. Passing MONDAY as an input instead of Monday will throw an error.

The following sequence diagram shows how the group operation works:

image::GroupSequenceDiagram.png[width="650"]

=== Students payment feature

    1. Current implementation

        The Payment mechanism is facilitated by VersionedAddressBook and FilteredList<Person>. VersionedAddressBook extends from AddressBook and classes related to Payment calls methods from VersionedAddressBook to retrieve students' data, update them and display accordingly.

        To be clearer, classes that are related to Payment and their functionality are as listed below:
        a. AddressBookParser:
            -Creates a PayCommandParser object and calls parse method in object to parse user's argument input.
        c. PayCommandParser
            -Analyses the user's input and checks for any violation of syntax.
            -Creates a Payment object with users' input.
            -Returns a PayCommand object with Payment object being fed in.
        b. PayCommand:
            -Takes in a Payment object in its constructor
            -Calls on methods in VersionedAddressBook to update new Payments made.
        d. Payment:
            -Contains fields to store student id, amount paid, month of payment and year of payment.
        e. XmlAdaptedPay
            -Responsible for converting the format of data so that it can be displayed below the command text box and stored.
        f. BrowserPanel
            -Responsible for displaying payment details in browser panel.

    2. Example usage scenario

        2a. The tutor launches the application and wants to record a payment for his/her student called Alice.
        2b. He/she makes a mental note of Alice's student index as listed in the left side of the application.
        2c. Lets say, Alice has student id 2. The payment she made was $400 for the month and year of November 2018. He/she proceeds to key in command in the following format: paid idx/2 amt/400 m/11 y/2018
            2C1. The tutor's input is passed from the text box through LogicManager class to AddressBookParser. AddressBookParser sieves out the arguments and command word(in this case, paid) and creates the PayCommandParser object, followed by calling parse method, with the arguments passed in.
            2C3. From the prefixes, PayCommandParser makes use of ArgumentMultimap to check if the inputs are of the correct format and it initialises a Payment object with the inputs.
            2C4. The PayCommandParser method then returns a PayCommand object with payment object.
            2C5. This is propagated back to the LogicManager class which then proceed to call execute method in the returned PayCommand object.
            2C6. The execute method in PayCommand proceed to obtain the list of students from the model. Since 2 is a valid student index, it proceeds to retrieve information from Alice Person class.
            2C7. Alice person class contains payment class. The PayCommand execute method proceeds to call the method updatePayments, then calls updatePerson in model class to modify Alice Person class with the new updated payment.
        2d. Now, payment details have been updated and the tutor will be able to see a payment updated successfully message below the command text box and the list of payments as well as other details about Alice
            2D1. XmlAdaptedPay is responsible for converting the data type to the appropriate data type for display through the toModelType method.
        2e. The tutor may also choose to view the details from browser panel by clicking on Alice tab on the left. Payments will be displayed in one of the rows.

    3. Other details

        a. Payment list will keep up to 10 payments at any one time. When the 11th payment is added, the payment list will remove the oldest payment record.
    4. The diagram below illustrates the sequence diagram.
image:PaymentSequenceDiagram.png[width="800"]

=== Tutor's Earnings feature
    1. Current implementation

        The Earnings mechanism is mainly facilitated by the filteredPersonList found in model. It works by checking through all past recorded payments for that specific month and year as requested by the tutor and returns the total earnings.
        The classes related to Earnings are EarningsCommand, EarningsCommandParser.
        a. EarningsCommandParser:
            -Takes in users' input and checks if it adheres to the required format.
            -Returns a EarningsCommand with the month and year passed in.
        b. EarningsCommand:
            -Takes in month and year as inputs in its constructor.
            -In Execute() method, it performs the checking of all recorded payments and returns the total payments received for that specified month and year.

    2. Example usage scenario

        2a. The tutor launches the application and wants to view his/her earnings for the month of November 2018.
        2b. He/she enters input in the format of: earnings m/11 y/2018
            2B1. The tutor's input is passed from the text box through LogicManager class to AddressBookParser. AddressBookParser sieves out the arguments and command word(in this case, earnings) and creates the EarningsCommandParser object, followed by calling parse method, with the arguments passed in.
            2C3. From the prefixes, EarningCommandParser makes use of ArgumentMultimap to check if the inputs are of the correct format.
            2C4. The PayCommandParser method then returns a EarningCommand object with month and year passed in.
            2C5. This is propagated back to the LogicManager class which then proceed to call execute method in the returned EarningsCommand object.
            2C6. The execute method in EarningsCommand proceed to obtain the list of students from the model and proceeds to search for Payment records made for that requested month and year.
            2C7. The amount is then returned.
        2c. The tutor will then see a message below the command text box, showing the earnings for the requested month and year.

    3. The diagram below illustrates the sequence diagram.
image:EarningsSequenceDiagram.png[width="800"]

// tag::copysub[]
=== Copy Subject feature
==== Current Implementation

The copy subject command operates by making a duplicate of the selected subject of the student and adds it the other student.

[NOTE]
If the other student already has the same subject, append the content of the subject instead. State of each syllabus is also copied.

Classes related to copy command and its functionality are listed below:

* `AddressBookParser` -- Creates CopySubCommandParser which parses the input from user.
* `CopySubCommandParser` -- Parses user's input into proper argument and creates CopySubCommand
* `CopySubCommand` -- Updates the target person based on the argument
* `SubjectsUtil` -- Manage the finding and copying aspect of copysub command.

Given below is an example usage scenario with 2 possible outcomes and how to copy function addresses each case.

Step 1. The user launches the application for the first time.

Step 2. Assuming that the application isn't empty, the user executes `copysub 1 2 4`.

Step 3. Assuming that each argument given is a valid input, the system will perform the copysub command.

Step 4. The system will locate the _first_ student from the student list, and make a separate copy of the _second_ subject stored under the student data.

Step 5. The system will locate the _fourth_ student from the student list, and make a decision.

* Step 5a. If the same subject as _second_ subject in Step 4, system will append the content of subject of _second_ subject into the _fourth_ student.
* Step 5b. If there is no subject same as _second_ subject in Step 4, system will add the _second_ subject as a new subject under the _fourth_ student.

The process is described with sequence diagram below:

image::CopySubSequenceDiagrams.png[width="650"]

=== Add / Delete Subject (Upcoming in v1.3)

==== Planned Implementation

The add / delete subject mechanism is facilitated with `AddressBookParser`.
Classes related to the functionality of the mechanism are listed below:

* `AddressBookParser` -- Creates a `AddSubCommandParser` / `DeleteSubCommandParser` object and parses the user's input.
* `AddSubCommandParser` / `DeleteSubCommandParser` -- Analyses user input to create a corresponding `Command` object.
* `AddSubCommand` / `DeleteSubCommand` -- Execution results in addition / deletion of a subject for a specified student index.

Given below is an example usage scenario of how the add / delete subject mechanism behaves at each step.

===== Add Subject

Step 1. The user launches the application.

Step 2. The tutor executes a command of the format `addsub STUDENT_INDEX s/SUBJECT` on the CLI.

Step 3. The arguments are parsed by `AddSubCommandParser`, which produces an instance of `AddSubCommand`.

Step 4. `AddSubCommand.execute()` is called, and the supplied subject is added for the student at the specified student index by TutorHelper.

===== Delete Subject

Step 1. The user launches the application.

Step 2. The tutor executes a command of the format `deletesub STUDENT_INDEX SUBJECT_INDEX` on the CLI.

Step 3. The arguments are parsed by `DeleteSubCommandParser`, which produces an instance of `DeleteSubCommand`.

Step 4. `DeleteSubCommand.execute()` is called, and the subject at the specified subject index of the student at the specified student index is deleted by TutorHelper.

[TIP]
The TutorHelper has to have at least 1 student as a precondition for both `addsub` and `deletesub`.
[TIP]
`deletesub` requires the student at the specified student index to have at least two subjects. After deletion, a student cannot have 0 subjects.

The following sequence diagram shows how the `addsub` operation works:

image::AddSubSequenceDiagram.png[width="650"]

The following sequence diagram shows how the `deletesub` operation works:

image::DeleteSubSequenceDiagram.png[width="650"]

== Glossary
. Subject : a branch of knowledge studied by the student
. Syllabus: the required topics to be covered under the subject
